% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/main.R
\name{rubitMain}
\alias{rubitMain}
\title{A general function to retrive raw data from a UbiTrail result file.}
\usage{
rubitMain(FILE, scale = 1, hz = 30, start_at = NA, end_at = NA,
  adj_fps = NA, xy_smoothing = 15, p = 0.001, speed_smoothing = 19,
  turn_resample_rate = 1, activity_window = 1, activity_min_speed = 0.1,
  n_radials = 1, n_slices = 1, area_rad = NA, thigmo_dist = NA,
  n_bootstraps = 20, a = 0, b = 0, c = 0,
  filterFUN = rubitMedianFilter, interpFUN = rubitLinearInterpolate,
  verbose = FALSE)
}
\arguments{
\item{FILE}{a .csv result file outputted by UbiTrail.}

\item{scale}{a numeric to calibrate the true spatial scale, in pixels per mm. At the default value, measurements are returned in pixels.}

\item{hz}{the frequency of resampling, in Hz. This argument is passed to the interpolation function.}

\item{start_at,end_at}{the desired start and end times to interpolate and/or cut data to, in minutes.}

\item{adj_fps}{encodes a new framerate, in Hz.}

\item{xy_smoothing}{the level of smoothing for raw trajectories. This argument is passed to the filter function.}

\item{p}{the proportion of least likely x,y-coordinates to remove based on log-likelihood. For example, for \code{p = 0.01}, the least likely 1\% of points will be removed and interpolated. See \code{\link{rubitRemoveOutliers}} for more information.}

\item{speed_smoothing}{the size of the rolling median window used to smooth speed and acceleration, in frames.}

\item{turn_resample_rate}{the number of seconds over which to resample X,Y-coordinate data and calculate turning angle from.}

\item{activity_window}{the window size used to define changes in activity, in seconds.}

\item{activity_min_speed}{the minimum speed threshold used to define changes in activity below which no movement is inferred, in mm/second.}

\item{n_radials}{the number of concentric circles to divide a circular area into.}

\item{n_slices}{the number of slices to divide a circular area into.}

\item{area_rad}{the minimum radius of the area. If an area shows insufficient movement to define a minimum enclosing circle of at least this radius, then a new minimum enclosing circle is calculated using \code{area_rad} and area metainformation stored in \code{attributes(m)}. This unit is defined in pixels unless \code{scale} != 1.}

\item{thigmo_dist}{the distance from the boundary perimeter defined as being central (i.e. not thigmotaxis), in mm. If thigmo_dist = NA, thigmotaxis is defined as movement in the outer 50\% of the area (i.e. > R/sqrt(2) from the area centre, where R is the radius of the whole area).}

\item{n_bootstraps}{the number of random data samples used to calculate the minimum enclosing circle defining each circular area.}

\item{a,b,c}{parameters to correct lens distortion. See \code{\link{lensCorrection}} for more information.}

\item{filterFUN}{the filter function to be used. It must have the same arguments as \code{\link{rubitMedianFilter}}.}

\item{interpFUN}{the interpolation function to be used. It must have the same arguments as \code{\link{rubitLinearInterpolate}}.}

\item{verbose}{logical; if TRUE, the function will print messages at every step.}
}
\value{
A list of numerical matrices. Each matrix corresponds to an area.
}
\description{
This function will load a result file as a list of matrices, before smoothing and resampling to calcuate the distance between successive positions for each area matrix.
}
\note{
The returned list contains a numerical matrix for each area. The attributes of list contain metadata and additional information is present in each of the attributes of each matrix.
Re-encoding a new framerate with \code{adj_fps} can correct potential errors made during video recording and/or tracking analysis. Check that the value returned by \code{\link{calcFPS}} matches the calculated framerate of the original video (e.g. using the 'ffprobe' function in FFmpeg [\url{https://ffmpeg.org/}].
}
\examples{
# my_file <- "Result.csv"
\dontrun{
data(tenebrio)
###See general metadata:
attributes(tenebrio)
###See informations about area '01':
attributes(tenebrio[['01']])

### Apply function over list of results files:
#filelist <- list.files()
#lapply(filelist, rubitMain, scale= 2.076, adj_fps = 19.05, hz = 20, n_radials = 8, n_slices = 12, b = -0.022, verbose = TRUE)

}
}
\seealso{
\code{\link{calcFPS}} for calculating the framerate of data, and \code{\link{rubitBasic}}, \code{\link{rubitCalcSpeed}}, \code{\link{rubitCalcPosition}}, \code{\link{rubitCalcTurning}}, and \code{\link{rubitCalcActivity}} to understand the different steps of processing used in this function.
}

