% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/basic.R
\name{rubitBasic}
\alias{rubitBasic}
\title{Reads a UbiTrail result file and performs basic processing.}
\usage{
rubitBasic(FILE, scale = 1, adj_fps = NA, hz = 30, start_at = NA,
  end_at = NA, xy_smoothing = 15, p = 0.001, nmin = xy_smoothing * 10,
  a = 0, b = 0, c = 0, filterFUN = rubitMedianFilter,
  interpFUN = rubitLinearInterpolate, verbose = FALSE)
}
\arguments{
\item{FILE}{a .csv result file outputted by UbiTrail.}

\item{scale}{a numeric to calibrate the true spatial scale, in pixels per mm. At the default value, measurements are returned in pixels.}

\item{adj_fps}{encodes a new framerate, in Hz.}

\item{hz}{the frequency of resampling, in Hz. This argument is passed to the interpolation function.}

\item{start_at,end_at}{the desired start and end times to interpolate and/or cut data to, in minutes.}

\item{xy_smoothing}{the level of smoothing for raw trajectories. This argument is passed to the filter function.}

\item{p}{the threshold used to remove outliers, as a proportion of the overall likelihood distribution; e.g. for \code{p = 0.01}, the largest 1\% of outliers will be removed. See \code{\link{rubitRemoveOutliers}} for more information.}

\item{nmin}{the minimal number of reads. If not enough reads are presents in an area, an empty matrix is returned.}

\item{a,b,c}{parameters to correct lens distortion. See \code{\link{lensCorrection}} for more information.}

\item{filterFUN}{the filter function to be used. It must have the same arguments as \code{\link{rubitMedianFilter}}.}

\item{interpFUN}{the interpolation function to be used. It must have the same arguments as \code{\link{rubitLinearInterpolate}}.}

\item{verbose}{logical; if TRUE, the function will print messages at every step.}
}
\value{
A list of numerical matrices, with each matrix corresponding to an area. The attributes of list contain metadata about the original video file and attributes of each matrix contain information on the dimensions of the area.
}
\description{
This function loads a UbiTrail result file as a list of matrices, before smoothing, interpolating and resampling in order to calculate distances between successive positions for each area matrix.
}
\note{
Re-encoding a new framerate with \code{adj_fps} can correct potential errors made during video recording and/or tracking analysis. Check that the value returned by \code{\link{calcFPS}} matches the calculated framerate of the original video (e.g. using the 'ffprobe' function in FFmpeg [\url{https://ffmpeg.org/}].
}
\examples{
data(tenebrio)

## See general metadata:
attributes(tenebrio)

## See information on area '01':
attributes(tenebrio[['01']])

### Create a filelist of all results files in a directory, e.g.
# filelist <- list.files()

### Read a single results file
rubitBasic(filelist[1], scale= 2.076, adj_fps = 19.05, hz = 20, b = -0.022, verbose = TRUE)

## Apply function over a list of results files:
lapply(filelist, rubitBasic, scale= 2.076, adj_fps = 19.05, hz = 20, b = -0.022, verbose = TRUE)
}
\seealso{
\code{\link{calcFPS}} for calculating the framerate of data, and \code{\link{rubitLinearInterpolate}}, \code{\link{rubitMedianFilter}}, and \code{\link{rubitRemoveOutliers}} to understand the different steps of processing used in this function.
}

