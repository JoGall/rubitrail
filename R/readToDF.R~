#' @include main.R
NULL
#' A general function to process tracking data from a UbiTrail result file.
#'
#' Processes individual lists of matrices containing raw UbiTrail results and returns a list containing a single dataframe of all results, as well as two elements containing meta-information.
#'
#' @param filelist a list of .csv files outputted from Ubitrail
#' @param calib a numeric to calibrate spatial scale, in pixels per mm
#' @param k the level of smoothing. This argument is passed to the filter function.
#' @param h the frequency of resampling, in Hz. This argument is passed to the interpolation function.
#' @param adj_fps encodes a new framerate, in Hz.
#' @param start_at,end_at the starting / ending times to interpolate and/or cut data to, in minutes.
#' @param t the threshold used to remove outliers, as a proportion of the overall likelihood distribution; e.g. for t = 0.01, the largest 1\% of outliers will be removed. Missing distances can then be interpolated using the function \code{\link{rubitInterpolate}}.
#' @param undistort_a,undistort_b,undistort_c,undistort_d parameters to correct lens distortion
#' @param verbose a boolean indicating if step-by-step information on processing is to be provided
#' @note calib can be readily calculated using many image manipulation tools, such as ImageJ (\url{https://imagej.nih.gov/ij/}).
#' The true framerate of a source video can be confirmed using several multimedia tools, such as FFmpeg (\url{https://ffmpeg.org/}).
#' Ready-made undistortion parameters for particular cameras can be found online (e.g. \url{http://sourceforge.net/projects/hugin/files/PTLens\%20Database}), or can be estimated manually using a checkerboard calibration image and the undistortion feature in some image manipulation programs, such as ImageMagick (\url{http://imagemagick.org}).
#' @return A list containing \code{[[1]]} a dataframe of tracking data for each area in each result file, with each unique area represented by a unique 'id' number, \code{[[2]]} a dataframe containing the dimensional information of each area, and \code{[[3]]} areas with no movement detected.
#' @examples
#' \dontrun{
#' ### Adjust framerate to 19.05 frames per second,
#' ### calibrate scale as 2.08 pixels per mm, and 
#' ### set lens correction parameters as: a = 0, 
#' ### b = -0.022, c = 0
#' dat <- rubitReadToDF(tenebrio.rda, 19.05, 2.08, undistort_b = -0.022)
#'
#' ### Heading of results dataframe
#' head(dat[[1]])
#'
#' ### Show areas in which no movement was detected
#' dat[[3]]
#'
#' }
#' @seealso \code{\link{rubitMain}} to understand the different steps of processing.
#' @export
rubitReadToDF <- function(filelist, calib, k = 15, h = 30, adj_fps = NA, start_at = NA, end_at = NA, t = 0.001, undistort_a = 0, undistort_b = 0, undistort_c = 0, undistort_d = 1, verbose = F) {

	#create empty storage
	master_xy <- data.frame()
	master_ID <- data.frame()
	master_area <- data.frame()
	tmp_i <- 1			#file loop ID
	id <- 1				#unique area ID
	
	##file loop
	for(i in unique(filelist)) {
		
		#display progress
		if(verbose) message("\nProcessing file ", tmp_i, " of ", length(unique(filelist)), ": ", i)
		
		#read raw data
		rawread <- rubitRead(i, k = k, h = h, adj_fps = NA, start_at = NA, end_at = NA, nmin = k*10, t = t, verbose = verbose)
		
		vidWidth <- as.numeric(attributes(rawread)$Width)
		vidHeight <- as.numeric(attributes(rawread)$Height)
		
		#create empty storage
		exp_xy <- data.frame()
		exp_ID <- data.frame()
		exp_area <- data.frame()
		NA_flag <- 0
		
		for(j in unique(names(rawread))) {
			
			#get meta data for each area
			filename <- i
			area <- attributes(rawread[[j]])$Area
			#calculate minimum circle for each area from mask
			areaW <- attributes(rawread[[j]])$W
			areaH <- attributes(rawread[[j]])$H
			areaX1 <- attributes(rawread[[j]])$X
			areaX2 <- areaX1 + attributes(rawread[[j]])$W
			areaY1 <- attributes(rawread[[j]])$Y
			areaY2 <- areaY1 + attributes(rawread[[j]])$H
			pLeft <- c(areaX1, (areaY1 + (areaH/2)))
			pRight <- c(areaX2, (areaY1 + (areaH/2)))
			pUp <- c((areaX1 + (areaW/2)), areaY1)
			pDown <- c((areaX1 + (areaW/2)), areaY2)
			#final matrix of points on circumference of area
			ss_area <- rbind(pLeft, pRight, pDown, pUp)
			#undistort area coordinates
			if(undistort_a != 0 | undistort_b != 0 | undistort_c !=0) {
				ss_area = undistortXY(ss_area[,1], ss_area[,2], undistort_a, undistort_b, undistort_c, undistort_d, imWidth = vidWidth, imHeight = vidHeight)
			}
			
			#process areas WITH movement detected
			if(attributes(rawread[[j]])$tags.hasEnoughPoints == TRUE) {
				
				#create variables
				area_full <- rep(area, nrow(rawread[[j]]))
				id_full <- rep(id, nrow(rawread[[j]]))
				filename_full <- rep(filename, nrow(rawread[[j]]))
				
				#correct lens distortion, if necessary
				X <- rawread[[j]][,"X"]
				Y <- rawread[[j]][,"Y"]
				if(undistort_a != 0 | undistort_b != 0 | undistort_c !=0) {
					temp <- undistortXY(X, Y, undistort_a, undistort_b, undistort_c, undistort_d, imWidth = vidWidth, imHeight = vidHeight)
					X <- temp$X
					Y <- temp$Y
					rm(temp)
				}
				
				#convert distances from pixels to mm
				Distance <- rawread[[j]][,"Distance"] / calib
				
				##output
				#create individual area df
				ss_xy <- data.frame(id = id_full, filename = filename_full, area = area_full, X, Y, Distance, time = rawread[[j]][,"time"])
				
				#append area df to file df
				exp_xy <- rbind(exp_xy, ss_xy)
				
				movement_detected <- ""
			}
			
			#process areas WITHOUT movement detected
			else {
				if(NA_flag == 0) message("\nwarning: NAs returned in some areas, likely due no movement being detected. See '[[2]]' for all occurrences.\n")
				NA_flag <- NA_flag + 1
				movement_detected <- "no movement detected"
			}
			
			#areas information
			ss_area <- data.frame(id = rep(id, nrow(ss_area)), X = ss_area[,1], Y = ss_area[,2], row.names=NULL)
			exp_area <- rbind(exp_area, ss_area)
			
			#ID table
			ss_ID <- data.frame(id, filename, area, notes = movement_detected)
			exp_ID <- rbind(exp_ID, ss_ID)
			
			#increment unique id
			id <- id + 1	
		}
		
		#append experimental dfs to master df
		master_xy <- rbind(master_xy, exp_xy)
		master_ID <- rbind(master_ID, exp_ID)
		master_area <- rbind(master_area, exp_area)
		
		# update progress
		tmp_i <- tmp_i+1
	}
	
	#write .csv of IDs for each area
# 	write.csv(ID_df, "IDs.csv", row.names=F)

	#output master data
	return(list(master_xy, master_ID, master_area))
}
