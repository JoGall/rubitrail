#' @include utils.R
#' @include calcFPS.R
#' @include removeOutliers.R
#' @include medianFilter.R
#' @include linearInterpolate.R
#' @include calcSpeed.R
#' @include calcPosition.R
#' @include calcTurning.R
#' @include calcActivity.R
NULL
#' A general function to retrive raw data from a UbiTrail result file.
#'
#' This function will load a result file as a list of matrices, before smoothing and resampling to calcuate the distance between successive positions for each area matrix.
#' 
#' @param FILE a .csv result file outputted by UbiTrail.
#' @param scale a numeric to calibrate the true spatial scale, in pixels per mm. At the default value, measurements are returned in pixels.
#' @param adj_fps encodes a new framerate, in Hz.
#' @param hz the frequency of resampling, in Hz. This argument is passed to the interpolation function.
#' @param start_at,end_at the desired start and end times to interpolate and/or cut data to, in minutes.
#' @param xy_smoothing the level of smoothing for raw trajectories. This argument is passed to the filter function.
#' @param p the proportion of least likely x,y-coordinates to remove based on log-likelihood. For example, for \code{p = 0.01}, the least likely 1\% of points will be removed. See \code{\link{rubitRemoveOutliers}} for more information.
#' @param speed_smoothing the size of the rolling median window used to smooth speed and acceleration, in frames.
#' @param turn_resample_rate the number of seconds over which to resample X,Y-coordinate data and calculate turning angle from.
#' @param activity_window the window size used to define changes in activity, in seconds.
#' @param activity_min_speed the minimum speed threshold used to define changes in activity below which no movement is inferred, in mm/second.
#' @param n_radials the number of concentric circles to divide a circular area into.
#' @param n_slices the number of slices to divide a circular area into.
#' @param thigmo_dist the distance from the boundary perimeter defined as being central (i.e. not thigmotaxis), in mm. If thigmo_dist = NA, thigmotaxis is defined as movement in the outer 50\% of the area (i.e. > R/sqrt(2) from the area centre, where R is the radius of the whole area).
#' @param n_bootstraps the number of random data samples used to calculate the minimum enclosing circle defining each circular area.
#' @param a,b,c parameters to correct lens distortion. See \code{\link{lensCorrection}} for more information.
#' @param filterFUN the filter function to be used. It must have the same arguments as \code{\link{rubitMedianFilter}}.
#' @param interpFUN the interpolation function to be used. It must have the same arguments as \code{\link{rubitLinearInterpolate}}.
#' @param verbose a boolean. If TRUE, the function will print messages at every step.
#' @note The returned list contains a numerical matrix for each area. The attributes of list contain metadata and additional information is present in each of the attributes of each matrix.
#' Re-encoding a new framerate with \code{adj_fps} can correct potential errors made during video recording and/or tracking analysis. Check that the value returned by \code{\link{calcFPS}} matches the calculated framerate of the original video (e.g. using the 'ffprobe' function in FFmpeg [\url{https://ffmpeg.org/}].
#' @return A list of numerical matrices. Each matrix corresponds to an area.
#' @examples
#' # my_file <- "Result.csv"
#' \dontrun{
#' data(tenebrio)
#' ###See general metadata:
#' attributes(tenebrio)
#' ###See informations about area '01':
#' attributes(tenebrio[['01']])
#'
#' ### Apply function over list of results files:
#' #filelist <- list.files()
#' #lapply(filelist, rubitMain, scale= 2.076, adj_fps = 19.05, hz = 20, n_radials = 8, n_slices = 12, b = -0.022, verbose = TRUE)
#'
#' }
#' @seealso \code{\link{calcFPS}} for calculating the framerate of data, and \code{\link{rubitBasic}}, \code{\link{rubitCalcSpeed}}, \code{\link{rubitCalcPosition}}, \code{\link{rubitCalcTurning}}, and \code{\link{rubitCalcActivity}} to understand the different steps of processing used in this function.
#' @export
rubitMain <- function(FILE, scale = 1, adj_fps = NA, hz = 30, start_at = NA, end_at = NA, xy_smoothing = 15, p = 0.001, speed_smoothing = 19, turn_resample_rate = 1, activity_window = 1, activity_min_speed = 0.1, n_radials = 1, n_slices = 1, thigmo_dist = NA, n_bootstraps = 20, a = 0, b = 0, c = 0, filterFUN = rubitMedianFilter, interpFUN = rubitLinearInterpolate, verbose = FALSE){

	#load raw file
	l <- rubitLoadFile(FILE)
	#original attributes
	atrs <- attributes(l)  

	#lens correction
	imWidth <- as.numeric(attributes(l)$Width)
	imHeight <- as.numeric(attributes(l)$Height)
	l <- lapply(l, lensCorrection, imWidth, imHeight, a = a, b = b, c = c)
		
	if(p > 0) {
		if(verbose) print(sprintf("Removing outliers..."))
		l <- lapply(l, rubitRemoveOutliers, p = p )
	}

	if(verbose) print(sprintf("Filtering data..."))
	l <- lapply(l, filterFUN, xy_smoothing )
	
	if(verbose) print("Interpolating data..")
	l <- lapply(l, interpFUN, hz = hz, adj_fps = adj_fps, start_at = start_at, end_at = end_at, minRow = xy_smoothing*10)
	
	if(verbose) print("Calculating distances...")
	l <- lapply(l, rubitCalcDistance, scale = scale )

	if(verbose) print(sprintf("Calculating position..."))
	l <- lapply(l, rubitCalcPosition, n_radials, n_slices, thigmo_dist, scale = scale, n_bootstraps )
	
	if(verbose) print(sprintf("Calculating speeds..."))
	l <- lapply(l, rubitCalcSpeed, window = speed_smoothing )
	
	if(verbose) print(sprintf("Resampling and calculating turning angles..."))
	turning <- lapply(l, rubitCalcTurning, resample = turn_resample_rate )

	if(verbose) print(sprintf("Calculating activity status..."))
	activity <- lapply(l, rubitCalcActivity, window = activity_window, min_speed = activity_min_speed)
	
	attributes(l) <- atrs  #reinstate attributes

	#return three datasets as a list of lists of matrices
    return(list(speeds = l, turning = turning, activity = activity))
}