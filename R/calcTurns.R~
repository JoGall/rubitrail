#' @include rubitMain.R
#' Calculates turning angles from X,Y-trajectories
#'
#' Calculates turning angle between successive vectors of movement by resampling data to minimise jitter. Outputs both absolute and relative angles in degrees
#'
#' @param df a dataframe containing processed tracking data outputted by \code{\link{rubitReadRaw}}
#' @param resampleRate the number of seconds over which to resample X,Y-coordinate data and calculate turning angle from
#' @note a separate dataframe is outputted as the input data is likely downsampled
#' @return a dataframe containing turning data for each area
#' @examples
#' \dontrun{
#' dat <- rubitReadRaw(tenebrio.rda)[[1]]
#' dat2 <- rubitInterpolateTime(dat, 0, 60)
#' dat3 <- calcSpeed(dat2, windowSize = 1)
#' dat4 <- calcTurns(dat3)
#' }
#' @seealso \code{\link{rubitMain}} to understand the different steps of processing.
#' @export
calcTurns <- function(df, resampleRate = 1) {

	#resample data
	resampleRate <- resampleRate * calcFPS(df)
	#create empty storage
	global_df <- data.frame()
	
	#make progress bar
	tmp <- 1
	pb <- txtProgressBar(min = 0, max = length(unique(df$id)), style = 3)

	##loop
	for(i in unique(df$id)){
		ss <- subset(df, id == i)

		#smooth X and Y coordinates
		#ss$X <- runmed(ss$X, smoothing)
		#ss$Y <- runmed(ss$Y, smoothing)

		#resample data		
		ss <- ss[seq(1, nrow(ss), by = resampleRate),]

		#calculate turning angles
		v <- diff(complex(real = ss$smoothX, imaginary = ss$smoothY))
		size <- Mod(v)
		absAngle <- c(NA, diff(Arg(v)) %% (2*pi), NA ) * 360/(2*pi)
		relAngle <- ifelse(absAngle > 180, -(360 - absAngle), absAngle)
	
		#calculate distance moved in resampled period	
		X1 <- c(ss$smoothX, NA)
		X0 <- c(NA, ss$smoothX)
		Y1 <- c(ss$smoothY, NA)
		Y0 <- c(NA, ss$smoothY)
		dX <- X1 - X0
		dY <- Y1 - Y0
		D <- sqrt(dX^2 + dY^2)
		D[length(D)-1] <- D[length(D)]
		D <- D[-1]
		D <- c(NA, D[-length(D)])
		
		#rebuild tags
		filename <- rep(as.integer(unique(ss$filename)), nrow(ss))
		area <- rep(as.factor(unique(ss$area)), nrow(ss))
		id <- rep(as.integer(unique(ss$id)), nrow(ss))
		
		#new dataframe
		ss_df <- data.frame(id, filename, area, X = ss$smoothX, Y = ss$smoothY, Distance = D, time = ss$time, absAngle = round(absAngle,3), relAngle = round(relAngle,3), id)
		global_df <- rbind(global_df, ss_df)
		
		# update progress bar
		Sys.sleep(0.1)
   		setTxtProgressBar(pb, tmp)
   		tmp <- tmp+1
	}
	close(pb)
	return(global_df)
}