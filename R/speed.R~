#' @include main.R
NULL
#' Smooths X,Y-coordinates and defines velocity metrics.
#'
#' Smooths X,Y-coordinates using a rolling median and recalculates distance, speed and acceleration moved based upon smoothed trajectories.
#'
#' @param df a dataframe containing processed tracking data outputted by \code{\link{rubitReadToDF}}.
#' @param window size of the rolling median window used to smooth speed.
#' @param verbose a boolean indicating if step-by-step information on processing is to be provided.
#' @note TODO
#' @return The inputted dataframe with distance and speed data added for each area and for each timepoint.
#' @examples
#' \dontrun{
#' dat <- rubitReadToDF(tenebrio.rda)[[1]]
#' dat2 <- rubitInterpolTime(dat, 0, 60)
#' dat3 <- rubitSpeed(dat2, window = 1)
#'
#' }
#' @seealso \code{\link{rubitMain}} to understand the different steps of processing.
#' @export
rubitSpeed <- function(df, window = 30, verbose = FALSE) {

	#create empty storage
	global_df <- data.frame()
	
	#make progress bar
	if(verbose){
		tmp <- 1
		pb <- txtProgressBar(min = 0, max = length(unique(df$id)), style = 3)
	}
	
	##loop
	for(i in unique(df$id)){
		ss <- subset(df, id == i)

		#calculate FPS
		FPS <- calcFPS(df)
	
		#define metrics
		rawSpeed <- ss$Distance * FPS
		smoothSpeed <- rollapply(ss$Distance, window, function(x) median(x), fill=NA)
		rawAccel <- abs(c(NA, diff(rawSpeed) ) )  #acceleration defined as *absolute* change in speed
		smoothAccel <- abs(c(NA, rollapply(rawSpeed, window, function(x) median(x), fill=NA)))
		smoothAccel_post <- abs(c(NA, diff(smoothSpeed) ) )
		
		#new dataframe
		ss_df <- data.frame(id = ss$id, filename = ss$filename, area = ss$area, rawX = ss$X, rawY = ss$Y, smoothX, smoothY, rawDistance = ss$Distance, smoothDistance = smoothDistance, rawSpeed, smoothSpeed, rawAccel, smoothAccel, time = ss$time)
		
		global_df <- rbind(global_df, ss_df)
		
		# update progress bar
		if(verbose){
			Sys.sleep(0.1)
			setTxtProgressBar(pb, tmp)
			tmp <- tmp+1
		}
	}
	if(verbose)	close(pb)
	
	return(global_df)
}