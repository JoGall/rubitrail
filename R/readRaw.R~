#' @include rubitMain.R
#' A general function to process tracking data from a UbiTrail result file.
#'
#' Processes individual lists of matrices containing raw UbiTrail results and returns a list containing a single dataframe of all results, as well as two elements containing meta-information.
#'
#' @param filelist a list of .csv files outputted from Ubitrail
#' @param pxmm a numeric to calibrate spatial scale, in pixels per mm
#' @param adj_fps a numeric to adjust the framerate, in frames per second. If adj_fps = 0, framerate will remain unadjusted
#' @param undistort_a,undistort_b,undistort_c,undistort_d parameters to correct lens distortion
#' @note pxmm can be readily calculated using many image manipulation tools, such as ImageJ (\url{https://imagej.nih.gov/ij/}).
#' The true framerate of a source video can be confirmed using several multimedia tools, such as FFmpeg (\url{https://ffmpeg.org/}).
#' Ready-made undistortion parameters for particular cameras can be found online (e.g. http://sourceforge.net/projects/hugin/files/PTLens%20Database), or can be estimated manually using a checkerboard calibration image and the undistortion feature in some image manipulation programs, such as ImageMagick (\url{http://imagemagick.org}).
#' @return A list containing three elements: [[1]] a dataframe of tracking data for each area in each result file, with each unique area represented by a unique 'id' number; [[2]] a dataframe containing the dimensional information of each area; [[3]] areas with no movement detected.
#' @examples
#' \dontrun{
#' ### Adjust framerate to 19.05 frames per second, calibrate scale as 2.08 pixels per mm, and set lens undistortion parameters as: a = 0, b = -0.022, c = 0
#' dat <- rubitReadRaw(tenebrio.rda, 19.05, 2.08, undistort_b = -0.022)
#' ### Heading of results dataframe
#' head(dat[[1]])
#' ### Show areas in which no movement was detected
#' dat[[3]]
#' }
#' @seealso \code{\link{rubitMain}} to understand the different steps of processing.
#' @export
rubitReadRaw <- function(filelist, pxmm, adj_fps = 0, undistort_a = 0, undistort_b = 0, undistort_c = 0, undistort_d = 1) {

	master_df <- data.frame()
	tmp_i <- 1			#file loop ID
	id <- 1				#unique area ID
	
	##file loop
	for(i in unique(filelist)) {
		
		#display file read
		message("Reading ", tmp_i, " of ", length(unique(filelist)), " files:\n", i)
		
		#read raw data
		rawread <- ubitBasic(i)
		
		#create empty storage
		exp_df <- data.frame()
		NAs_df <- data.frame()
		areas_df <- data.frame()
		
		##area loop
		tmp_j <- 1
		
		for(j in unique(names(rawread))) {
		
			#progress message
			message(paste0("Processing area ", tmp_j, " of ", length(unique(names(rawread)))), ": '", j, "'")
			tmp_j <- tmp_j + 1
			
			#get meta data for each area
			filename <- i
			area <- attributes(rawread[[j]])$Area
			#calculate minimum circle for each area from mask
			areaW <- attributes(rawread[[j]])$W
			areaH <- attributes(rawread[[j]])$H
			areaX1 <- attributes(rawread[[j]])$X
			areaX2 <- areaX1 + attributes(rawread[[j]])$W
			areaY1 <- attributes(rawread[[j]])$Y
			areaY2 <- areaY1 + attributes(rawread[[j]])$H
			pLeft <- c(areaX1, (areaY1 + (areaH/2)))
			pRight <- c(areaX2, (areaY1 + (areaH/2)))
			pUp <- c((areaX1 + (areaW/2)), areaY1)
			pDown <- c((areaX1 + (areaW/2)), areaY2)
			#final matrix of points on circumference of area
			xyArea <- rbind(pLeft, pRight, pDown, pUp)
			
			#process areas WITH movement detected
			if(attributes(rawread[[j]])$tags.hasEnoughPoints == TRUE) {
				
				#create variables
				area_full <- rep(area, nrow(rawread[[j]]))
				id_full <- rep(id, nrow(rawread[[j]]))
				filename_full <- rep(filename, nrow(rawread[[j]]))
				
				#correct lens distortion, if necessary
				X <- rawread[[j]][,"X"]
				Y <- rawread[[j]][,"Y"]
				if(undistort_a != 1 | undistort_b != 1 | undistort_c !=1){
					temp <- undistortXY(X, Y, undistort_a, undistort_b, undistort_c, undistort_d)
					X <- temp$X
					Y <- temp$Y
					rm(temp)
				}
				
				#recalculate time interval, if necessary
				if(adj_fps != 0){
					#modal time interval
					itv <- median(diff(rawread[[j]][,4]))
					time_correction_factor <- (1000/itv) / adj_fps
					time <- rawread[[j]][,4] * time_correction_factor
				} else {
					time <- rawread[[j]][,4]
				}
				
				#recalculate distance variable
				Distance <- c(0, sqrt(diff(X)^2 + diff(Y)^2))
				
				#calibrate distance from pixels to mm
				Distance <- Distance / pxmm	
				
				##output
				#create individual area dfs
				ss_df <- data.frame(id = id_full, filename = filename_full, area = area_full, X, Y, Distance, time)
				ss_areas <- data.frame(id = rep(id, nrow(xyArea)), X = xyArea[,1], Y = xyArea[,2], row.names=NULL)
				
				#append to local experimental dfs
				exp_df <- rbind(exp_df, ss_df)
				areas_df <- rbind(areas_df, ss_areas)
			}
			
			#process areas WITHOUT movement detected
			else {
				message("warning: NAs returned, likely due to zero detected movement of current object")
				NAs_df <- rbind(NAs_df, data.frame(filename, area))
				}
				
			id <- id + 1
			
		}
		#append to global master df
		master_df <- rbind(master_df, exp_df)
		
		# update progress
		tmp_i <- tmp_i+1
	}
	
	#create unique ID label for each set-up
#	master_df$id <- as.numeric(as.factor(with(master_df, paste(exp, rep, area, sep="_"))))

	#output global data
	return(list(master_df, areas_df, NAs_df))
}


## helper functions

undistortXY <- function(x, y, a, b, c, d = 1, imWidth = 640, imHeight = 480) {
		
		normX <- x - (imWidth / 2)
		normY <- y - (imHeight / 2)

		radius_u <- sqrt(imWidth^2 + imHeight^2)
		
		r <- sqrt(normX^2 + normY^2) / 	radius_u
		
		Rsrc <- r * (a*r^3 + b*r^2 + c*r + d)
		
		theta <- ifelse(Rsrc == 0, 1, 1 / atan(Rsrc) * Rsrc)
		
		newX <- (imWidth / 2) + theta * normX
		newY <- (imHeight / 2) + theta * normY
		
		return(data.frame(X = newX, Y = newY))
}
