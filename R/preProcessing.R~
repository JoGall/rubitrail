#' @include input.R
NULL
#' A general function to retrive raw data from a UbiTrail result file.
#'
#' This function will load a result file as a list of matrices. 
#' Then, the data in each matrix is smoothed, resampled and the distance between successive positions is calculated.
#' This function is essentially a wrapper for other functions also available in rubitrail package.
#' 
#' @param FILE the name of the file which the metadata are to be read from.
#' @param filterFUN the filter function to be used. It must have the same argument as \code{\link{rubitMedianFilter}}.
#' @param k the level of smoothing. This argument is passed to the filter function.
#' @param interpFUN the interpolation function to be used. It must have the same argument as \code{\link{rubitInterpolate}}.
#' @param h the frequency of resampling, in Hz. This argument is passed to the interpolation function.
#' @param nmin the minimal number of reads. If not enough reads are presents in an area, the corresponding matrix is emptied.
#' @param nThread a positive integer. The number of threads to be created for parallel processing.
#' @param t a distance threshold to remove outliers, as a percentage of distribution of distances. e.g. for t = 0.01, the largest 1% of distances moved will be removed from the data. Missing distances can be interpolated using the function \code{\link{rubitInterpolate}}.
#' @param verbose a boolean. If TRUE, the function will print messages at every step.
#' @note The returned list contains a numerical matrix for each area.
#' The attributes of list contain metadata and additional information is present in each of the attributes of each matrix.
#' Each matrix in the list is given attributes about the area it represents.
#' @return A list of numerical matrices. Each matrix corresponds to an area.
#' @examples
#' data(weevils)
#' ###See general metadata:
#' attributes(weevils)
#' ###See how many reads in each area:
#' summary(weevils)
#' ###See informations about the area named '08':
#' attributes(weevils[['08']])
#' \dontrun{
#' data2 <- rubitBasic('Results.csv') 
#' }
#' @note Processing can be protracted for large datasets. If your experiment was long and contained multiple active areas, you should consider using multiple threads to speed up processing.
#' @seealso \code{\link{rubitCalcDistance}}, \code{\link{rubitInterpolate}}, \code{\link{rubitMedianFilter}}, and \code{\link{rubitRemoveOutliers}} to understand the different steps of pre-processing.
#' @export
rubitBasic <- function(FILE, filterFUN = rubitMedianFilter, k = 15, interpFUN = rubitInterpolate, h = 30, nmin = k*10, nThread = 1, t = 0.001, verbose = FALSE){
	l <- rubitLoadFile(FILE, verbose)
	# we save the attributes of l:
	atrs <- attributes(l);
    if(nThread > 1){
		if(verbose) print(sprintf("Creating a team of %i threads...", nThread))
		cl <- makeCluster(nThread)
		if(t > 0){
			if(verbose) print(sprintf("Removing outliers..."))#Removing outliers
			l <- parLapply(cl, l, rubitRemoveOutliers, t )
			}


		if(verbose) print(sprintf("Filtering data..."))#Filtering
		l <- parLapply(cl, l, filterFUN, k )
		
		if(verbose) print("Interpolating data..")#Interpolating
		l <- parLapply(cl, l, interpFUN, h, minRow = nmin )
		
		if(verbose) print("Calculating distances...")#Calculating distances
		l <- parLapply(cl, l, rubitCalcDistance )
		
		if(verbose) print("Stopping cluster...")#Stopping cluster   
		stopCluster(cl)
	}
	else{
		if(t > 0){
			if(verbose) print(sprintf("Removing outliers..."))#Removing outliers
			l <- lapply(l, rubitRemoveOutliers ,t )
			}

		if(verbose) print(sprintf("Filtering data..."))#Filtering
		l <- lapply(l, filterFUN ,k )
		
		if(verbose) print("Interpolating data..")#Interpolating
		l <- lapply(l, interpFUN ,h,minRow = nmin)
		
		if(verbose) print("Calculating distances...")#Calculating distances
		l <- lapply(l, rubitCalcDistance )     
	}
	
	attributes(l) <- atrs
    return(l)
}
#' @include filters.R
#' @include interpolXY.R
NULL
#' Calculates distance between each read of an area matrix.
#'
#' This function calculates distance between the position at any read and the position at the next read.
#' This is achieved by using Pythagoras' theorem. 
#' @param m an area matrix.
#' @return A new area matrix.
#  @note TODO
#' @examples
#' data(weevils)
#' w15 <- lapply(weevils,rubitMedianFilter,k=15)
#' w15_intp <- lapply(w15,rubitInterpolate,h=10)
#' w15_Dist <- lapply(w15_intp,rubitCalcDistance)
#' ##Histogram of instantaneous speed (pix/sec)
#' hist(w15_Dist[['08']][,'Distance']*10,nclass=100)
#' ###Histogram of instantaneous speed (m/sec) 
#' ##6400px = 1m
#' d <- cumsum(w15_Dist[['08']][,'Distance']/6400)
#' ##60000ms = 1min
#' t <- w15_Dist[['08']][,'time']/60000
#' plot(d ~ t, type='l', ylab = "Cumul. distance (m)", xlab = "time (min)")
#' @seealso \code{\link{rubitMedianFilter}} to filter data and \code{\link{rubitInterpolate}} to resample data.
#' @export
rubitCalcDistance <- function(m){
	
	if(!any(class(m) == "matrix"))
		stop(sprintf("The function %s expected argument 'm' to be a matrix. If you have a a list of matrices, use lapply to call this function on each element of the list. See examples for details.",gettext(match.call()[[1]]) ))
		
	overwrite <- FALSE
	if(any(attributes(m)$dimnames[[2]] == "Distance")){
		overwrite <- TRUE
		warning("These distances have already been calculated for this data matrix. Overwriting the data.")
	}
	
		
	if(attributes(m)$tags.hasEnoughPoints){
		
		X <- c(m[,'X'],NA)
		lagX <- c(NA,m[,'X'])
		Y <- c(m[,'Y'],NA)
		lagY <- c(NA,m[,'Y'])
		
		dX <- X - lagX
		dY <- Y - lagY
		
		D <- sqrt(dX^2 + dY^2)
		D[length(D)-1] <- D[length(D)]
		D <- D[-1]
		if(!overwrite)
			mm <- cbind(m,Distance = D)
		else{
			mm <- m
			mm[,'Distance'] <- D
			}
		
		atr <-attributes(m)
		atr$dim <- attributes(mm)$dim
		atr$dimnames <- attributes(mm)$dimnames
		attributes(mm) <- atr
		}
	else{
		D<- numeric()
		if(!overwrite)
			mm <- cbind(m,Distance = D)
		else{
			mm <- m
			mm[,'Distance'] <- D
			}
#~ 		mm <- cbind(m,Distance = D)
		atr <-attributes(m)
		atr$dim <- attributes(mm)$dim
		atr$dimnames <- attributes(mm)$dimnames
		attributes(mm) <- atr
	}
	mm
}
#' @include filters.R
NULL
#' Resample data from an area matrix.
#' 
#' This function returns position from reads at a regular time interval.
#' This is perfomed through linear interpolation.
#' @param m a numerical matrix corresponding to an area.
#' @param h the desired resampling frequency in Hz.
#' @param minRow an integer defining the minimal number of reads. If less than minRow reads are present in m, the function returns an empty matrix.
#' @return A new area matrix.
#' @note The new matrix will likely have a different number of rows than the source matrix. 
#' The attributes of the source matrix are copied to the new matrix.
#' @examples
#' data(weevils)
#' w15 <- lapply(weevils,rubitMedianFilter,k=15)
#' ##Before resampling
#' t <- (w15[['08']][,'time'] > 40*1000 & w15[['08']][,'time'] < 80*1000)
#' plot(w15[['08']][t,'X'] ~ w15[['08']][t,'time'],col='blue',pch='x',cex=0.5)
#' ##After resampling
#' w15_intp <- lapply(w15,rubitInterpolate,h=10)
#' t_intp <- (w15_intp[['08']][,'time'] > 40*1000 & w15_intp[['08']][,'time'] < 80*1000)
#' points(w15_intp[['08']][t_intp,'X'] ~ w15_intp[['08']][t_intp,'time'],col='red',pch=20,cex=0.5)
#  ubiMetaData('Results.csv')
#'
#' @seealso \code{\link{rubitMedianFilter}} to smooth data (before interpolation).
#' @export
rubitInterpolate <- function(m, h = 30, minRow = 11){
	
	if(!any(class(m) == "matrix"))
		stop("This function works with a matrix. If you have a a list of matrices, use lapply to call this function on each element of the list. See examples for details.")
		
	if(attributes(m)$tags.isHomogenous)
		warning("This data matrix has already been resampled.")
		
	if(nrow(m) >= minRow & attributes(m)$tags.hasEnoughPoints){
		t0 <- m[1,'time']
		tf <- m[nrow(m),'time']
		dt <- (tf-t0)/1000
		n <- round(h*dt)
		t_out <- seq(from = t0, to = tf, length.out=n)
		
		xx <- approx(x=m[,'time'], y=m[,'X'],xout=t_out)$y

		yy <- approx(x=m[,'time'], y=m[,'Y'],xout=t_out)$y

		L <- approx(x=m[,'time'], y=m[,'L'],xout=t_out)$y
		
		T <- approx(x=m[,'time'], y=m[,'Territory'],xout=t_out,method='const')$y
		
		mm <- cbind(T,xx,yy,t_out,L)
		atr <- attributes(m)
		atr$dim <- attributes(mm)$dim
		attributes(mm) <-atr
		attributes(mm)$tags.hasEnoughPoints <- TRUE
		}
	else{
		mm <- m
		attributes(mm)$tags.hasEnoughPoints <- FALSE
	}
	attributes(mm)$tags.isHomogenous <- TRUE
	mm
}
#' @include input.R
#' @include interpolXY.R
NULL
#' Apply a running median filter on an an area matrix.
#' 
#' This function is used to eliminate outliers from an area matrix.
#' @param m a numerical matrix corresponding to an area.
#' @param k an integer specifying the size of the smoothing window. \emph{it must be odd}.
#' @return A numerical matrix of the same dimension as m.
#' @note 
#' A read is written by UbiTrail every time an agent is detected. Therefore, a read contains information
#' about area, territory, position and time.
#'  
#' @examples
#' ### Apply to a list of area matrix with different k values:
#' data(weevils)
#' w15 <- lapply(weevils,rubitMedianFilter,k=15)
#' w101 <- lapply(weevils,rubitMedianFilter,k=101)
#' ### See k impacts on smoothing:
#' ##Raw:
#' plot(weevils[['08']][1:2000,'X'] ~ weevils[['08']][1:2000,'time'],type='l',col='blue')
#' ##k=15 = OK:
#' lines(w15[['08']][1:2000,'X'] ~ w15[['08']][1:2000,'time'],col='green')
#' ##k=101 = over filtered:
#' lines(w101[['08']][1:2000,'X'] ~ w101[['08']][1:2000,'time'],col='red')
#'
#' @seealso \code{\link{rubitInterpolate}} to get a regular sampling after filtering.
#' @export
rubitMedianFilter <- function(m,k=15){
	if(!any(class(m) == "matrix"))
		stop(sprintf("The function %s expected argument 'm' to be a matrix. If you have a a list of matrices, use lapply to call this function on each element of the list. See examples for details.",gettext(match.call()[[1]]) ))
		
		
	if(attributes(m)$tags.isFiltered)
		warning("This data matrix has already been filtered. You are not working on raw data.")
	
		
	if(attributes(m)$tags.isHomogenous)
		warning("This data has been interpolated before smoothing. This will hardly remove outliers.")
	
	if(nrow(m) < 2*k){
		attributes(m)$tags.hasEnoughPoints <- FALSE
		}
		
	m[,'X'] <- runmed(m[,'X'],k)
	m[,'Y'] <- runmed(m[,'Y'],k)
	m[,'Territory'] <- runmed(m[,'Territory'],k) ##TODO(qg) this filter should be on on ordinal factor (not numeric)
	
	attributes(m)$tags.isFiltered <- TRUE
	m
}
#' @include input.R
#' @include interpolXY.R
NULL
#' Removes outliers based upon distance.
#' 
#' Removes outliers from a distribution of distances for each area matrix.
#' @param m a numerical matrix corresponding to an area.
#' @param t a distance threshold to remove outliers, as a percentage of distribution of distances. e.g. for t = 0.01, the largest 1% of distances moved will be removed from the data. Missing distances can be interpolated using the function \code{\link{rubitInterpolate}}.
#' @return A numerical matrix of the same dimension as m.
#' @note 
#' A read is written by UbiTrail every time an agent is detected. Therefore, a read contains information
#' about area, territory, position and time.
#'  
#' @examples
#' ### Apply to a list of area matrix with different k values:
#' data(weevils)
#' w15 <- lapply(weevils,rubitMedianFilter,k=15)
#' w101 <- lapply(weevils,rubitMedianFilter,k=101)
#' ### See k impacts on smoothing:
#' ##Raw:
#' plot(weevils[['08']][1:2000,'X'] ~ weevils[['08']][1:2000,'time'],type='l',col='blue')
#' ##k=15 = OK:
#' lines(w15[['08']][1:2000,'X'] ~ w15[['08']][1:2000,'time'],col='green')
#' ##k=101 = over filtered:
#' lines(w101[['08']][1:2000,'X'] ~ w101[['08']][1:2000,'time'],col='red')
#'
#' @seealso \code{\link{rubitInterpolate}} to get a regular sampling after filtering.
#' @export
rubitRemoveOutliers <- function(m, t = 0.001){
	if(nrow(m) < 5)
		return(m)
		
	if( t<0 || t>=0.5)
		stop("t must be between 0 and 0.5")
		
	v <- m[,'L']
	mv <- mean(v)
	sdv <- sd(v)
	t_l <- qnorm(t,mv,sdv,lower.tail= T)
#~ 	t_h <- qnorm(t,mv,sdv,lower.tail= F)
	invalid <- v < t_l
	
	mm <- m[v > t_l,]
	
	atr <- attributes(m)
	atr$dim <- attributes(mm)$dim
	attributes(mm) <- atr
	mm
}