#' @include medianFilter.R
#' @include linearInterpolate.R
NULL
#' Resample data from an area matrix.
#' 
#' This function returns position from reads at a regular time interval.
#' This is perfomed through linear interpolation.
#' @param m a numerical matrix corresponding to an area.
#' @param adj_fps encodes a new framerate, in Hz.
#' @param hz the desired resampling frequency, in Hz.
#' @param start_at,end_at the starting / ending times to interpolate and/or cut data to, in minutes.
#' @param minRow an integer defining the minimal number of reads. If less than minRow reads are present in m, the function returns an empty matrix.
#' @return A new area matrix.
#' @note The new matrix will likely have a different number of rows than the source matrix. 
#' The attributes of the source matrix are copied to the new matrix.
#' @examples
#' data(weevils)
#' w15 <- lapply(weevils,rubitMedianFilter,k=15)
#' ##Before resampling
#' t <- (w15[['08']][,'time'] > 40*1000 & w15[['08']][,'time'] < 80*1000)
#' plot(w15[['08']][t,'X'] ~ w15[['08']][t,'time'],col='blue',pch='x',cex=0.5)
#' ##After resampling
#' w15_intp <- lapply(w15, rubitLinearInterpolate, FPS = 20)
#' t_intp <- (w15_intp[['08']][,'time'] > 40*1000 & w15_intp[['08']][,'time'] < 80*1000)
#' points(w15_intp[['08']][t_intp,'X'] ~ w15_intp[['08']][t_intp,'time'],col='red',pch=20,cex=0.5)
#  ubiMetaData('Results.csv')
#'
#' @seealso \code{\link{rubitMedianFilter}} to smooth data before interpolation.
#' @export
rubitLinearInterpolate <- function(m, adj_fps = NA, hz = 30, start_at = NA, end_at = NA, minRow = 11){
	
	if(!any(class(m) == "matrix"))
		stop("This function works with a matrix. If you have a a list of matrices, use lapply to call this function on each element of the list. See examples for details.")
		
	if(attributes(m)$tags.isHomogenous)
		warning("This data matrix has already been resampled.")
		
	if(nrow(m) >= minRow & attributes(m)$tags.hasEnoughPoints){

#		#correct time intervals
# 		time_scalar <- 3.000849
# 		m[,'time'] = m[,'time'] * time_scalar
		
		#change framerate
		if(!is.na(adj_fps)){
			time_scalar <- 1000 / median(diff(m[,"time"])) / adj_fps
			m[,"time"] = m[,"time"] * time_scalar
		}
		
		#resample time
		t0 <- m[1,'time']
		tf <- m[nrow(m),'time']
		t_out <- seq(from = t0, to = tf, by = 1000 / hz)
		
		xx <- approx(x=m[,'time'], y=m[,'X'], xout=t_out)$y

		yy <- approx(x=m[,'time'], y=m[,'Y'], xout=t_out)$y

		L <- approx(x=m[,'time'], y=m[,'L'], xout=t_out)$y
		
		T <- approx(x=m[,'time'], y=m[,'Territory'], xout=t_out, method='const')$y
		
		mm <- cbind(T, xx, yy, t_out, L)
		
		#trim and/or interpolate timepoints
		new_times_start <- numeric()
		new_times_end <- numeric()	
		if(!is.na(start_at)) {
			start_at_ms <- start_at*60*1000
			mm = subset(mm, mm[,"t_out"] >= start_at_ms)
			if(start_at_ms < min(mm[,"t_out"]) - (1000/hz)){
				new_times_start <- seq(start_at_ms, min(mm[,"t_out"]) - (1000/hz), 1000 / hz)
			}
		}
		if(!is.na(end_at)) {
			end_at_ms <- end_at*60*1000
			mm = subset(mm, mm[,"t_out"] <= end_at_ms)
			if(end_at_ms > max(mm[,"t_out"] + (1000/hz))) {
				new_times_end <- seq(max(mm[,"t_out"]), end_at_ms, 1000 / hz)
			}
		}
		#adjust data length to match new timepoints (NA X,Y-position for opening frames; last documented X,Y-position inferred for closing frames)
		T_ <- c(rep(NA, length(new_times_start)), mm[,"T"], rep(NA, length(new_times_end)))
		xx_ = c(rep(NA, length(new_times_start)), mm[,"xx"], rep(xx[length(xx)], length(new_times_end)))
		yy_ = c(rep(NA, length(new_times_start)), mm[,"yy"], rep(yy[length(yy)], length(new_times_end)))
		t_out_ = c(new_times_start, mm[,"t_out"], new_times_end)
		L_ = c(rep(NA, length(new_times_start)), mm[,"L"], rep(NA, length(new_times_end)))
			
		m_out <- cbind(T_, xx_, yy_, t_out_, L_)
		
		#reassign attributes
		atr <- attributes(m)
		atr$dim <- attributes(m_out)$dim
		attributes(m_out) <-atr
		attributes(m_out)$tags.hasEnoughPoints <- TRUE
	
	} else {
		m_out <- m
		attributes(m_out)$tags.hasEnoughPoints <- FALSE
	}
	
	attributes(m_out)$tags.isHomogenous <- TRUE
	
	m_out
}