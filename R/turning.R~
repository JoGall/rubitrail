#' @include main.R
NULL
#' Calculates turning angles from trajectories.
#'
#' Calculates turning angle between successive vectors of movement by resampling data to minimise jitter, returning a dataframe containing both absolute and relative angles in degrees.
#'
#' @param df a dataframe containing processed tracking data outputted by \code{\link{rubitReadToDF}}.
#' @param window the number of seconds over which to resample X,Y-coordinate data and calculate turning angle from.
#' @note a separate dataframe is outputted as the input data is likely downsampled.
#' @param verbose a boolean indicating if step-by-step information on processing is to be provided.
#' @return a dataframe containing turning data for each area
#' @examples
#' \dontrun{
#' dat <- rubitReadToDF(tenebrio.rda)[[1]]
#' dat2 <- rubitInterpolateTime(dat, 0, 60)
#' dat3 <- rubitSpeed(dat2, windowSize = 1)
#' dat4 <- rubitTurning(dat3)
#' }
#' @seealso \code{\link{rubitMain}} to understand the different steps of processing.
#' @export
rubitTurning <- function(df, window = 9, verbose = FALSE) {

	#resample data
	window <- window * calcFPS(df)
	#create empty storage
	global_df <- data.frame()
	
	#make progress bar
	if(verbose){
		tmp <- 1
		pb <- txtProgressBar(min = 0, max = length(unique(df$id)), style = 3)
	}
	
	##loop
	for(i in unique(df$id)){
		ss <- subset(df, id == i)

		#smooth X and Y coordinates
		#ss$X <- runmed(ss$X, smoothing)
		#ss$Y <- runmed(ss$Y, smoothing)

		#resample data		
		ss <- ss[seq(1, nrow(ss), by = window),]

		#calculate turning angles
		v <- diff(complex(real = ss$X, imaginary = ss$Y))
		size <- Mod(v)
		absAngle <- c(NA, diff(Arg(v)) %% (2*pi), NA ) * 360/(2*pi)
		relAngle <- ifelse(absAngle > 180, -(360 - absAngle), absAngle)
	
		#calculate distance moved in resampled period	
		X1 <- c(ss$X, NA)
		X0 <- c(NA, ss$X)
		Y1 <- c(ss$Y, NA)
		Y0 <- c(NA, ss$Y)
		dX <- X1 - X0
		dY <- Y1 - Y0
		D <- sqrt(dX^2 + dY^2)
		D[length(D)-1] <- D[length(D)]
		D <- D[-1]
		D <- c(NA, D[-length(D)])
		
		#rebuild tags
		filename <- rep(as.integer(unique(ss$filename)), nrow(ss))
		area <- rep(as.factor(unique(ss$area)), nrow(ss))
		id <- rep(as.integer(unique(ss$id)), nrow(ss))
		
		#new dataframe
		ss_df <- data.frame(id, filename, area, X = ss$X, Y = ss$Y, Distance = D, time = ss$time, absAngle = round(absAngle,3), relAngle = round(relAngle,3))
		global_df <- rbind(global_df, ss_df)
		
		# update progress bar
		if(verbose){
			Sys.sleep(0.1)
			setTxtProgressBar(pb, tmp)
			tmp <- tmp+1
		}
	}
	if(verbose) close(pb)
	
	return(global_df)
}